{
    "results": {
        "usr/lib/libsemigroups_so_0_0_0": {
            "report-functions": [
                "pow", 
                "_ZSt9terminatev", 
                "_ITM_registerTMCloneTable", 
                "pthread_mutex_lock", 
                "_ZNSo5flushEv", 
                "__cxa_demangle", 
                "_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_createERjj", 
                "_ZNKSt8__detail20_Prime_rehash_policy14_M_need_rehashEjjj", 
                "__cxa_end_catch", 
                "_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructEjc", 
                "_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE10_M_replaceEjjPKcj", 
                "_ZSt20__throw_length_errorPKc", 
                "_ZNSt6thread6_StateD2Ev", 
                "__divdi3", 
                "_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7compareEPKc", 
                "__cxa_bad_typeid", 
                "__cxa_begin_catch", 
                "_ZdlPv", 
                "__moddi3", 
                "pthread_create", 
                "_ZNSt8ios_base4InitC1Ev", 
                "_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4swapERS4_", 
                "pthread_mutex_unlock", 
                "_ITM_deregisterTMCloneTable", 
                "abort", 
                "_ZNSt6thread15_M_start_threadESt10unique_ptrINS_6_StateESt14default_deleteIS1_EEPFvvE", 
                "_ZNSt8ios_base4InitD1Ev", 
                "_ZNSt6thread4joinEv", 
                "_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4findEPKcjj", 
                "__gxx_personality_v0", 
                "_ZSt16__throw_bad_castv", 
                "sqrt", 
                "_ZNSo3putEc", 
                "_Znwj", 
                "_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_appendEPKcj", 
                "_ZNSt6thread20hardware_concurrencyEv", 
                "memmove", 
                "free", 
                "_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1EOS4_", 
                "_ZSt11_Hash_bytesPKvjj", 
                "_ZNKSt5ctypeIcE13_M_widen_initEv", 
                "__cxa_finalize", 
                "_ZNKSt8__detail20_Prime_rehash_policy11_M_next_bktEj", 
                "_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE9_M_mutateEjjPKcj", 
                "__cxa_rethrow", 
                "__gmon_start__", 
                "_ZNSt8__detail15_List_node_base9_M_unhookEv", 
                "_ZNSt8__detail15_List_node_base7_M_hookEPS0_", 
                "memcmp", 
                "_ZSt17__throw_bad_allocv", 
                "_ZSt24__throw_out_of_range_fmtPKcz", 
                "_ZSt25__throw_bad_function_callv", 
                "vsnprintf", 
                "_ZNSt6chrono3_V212steady_clock3nowEv", 
                "_ZNSo9_M_insertImEERSoT_", 
                "_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_", 
                "__cxa_pure_virtual", 
                "__stack_chk_fail", 
                "_Unwind_Resume", 
                "_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i", 
                "__cxa_atexit", 
                "_ZSt19__throw_logic_errorPKc", 
                "_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate", 
                "pthread_self", 
                "__pthread_key_create", 
                "strlen"
            ], 
            "rpm": "libsemigroups-0.5.2-1.fc27.i686.rpm", 
            "complexity": {
                "r2aa": "failed: ERROR: Cannot find radare2 in PATH"
            }, 
            "hardening-check": {
                " Read-only relocations": "yes", 
                " Position Independent Executable": "no, regular shared library (ignored)", 
                " Stack protected": "yes", 
                " Fortify Source functions": "no, only unprotected functions found!", 
                " Immediate binding": "yes"
            }, 
            "filename": "usr/lib/libsemigroups.so.0.0.0"
        }
    }, 
    "metadata": {
        "spec_data": {
            "Group": " Unspecified", 
            "Name": " libsemigroups", 
            "License": " GPLv3+", 
            "URL": " https://github.com/james-d-mitchell/libsemigroups", 
            "Relocations": " (not relocatable)", 
            "Install Date": " (not installed)", 
            "Build Host": " buildhw-04.phx2.fedoraproject.org", 
            "Description": "\nLibsemigroups is a C++ library for semigroups and monoids; it is partly\nbased on \"Algorithms for computing finite semigroups\", \"Expository\nSlides\", and Semigroupe 2.01 by Jean-Eric Pin.\n\nThe libsemigroups library is used in the Semigroups package for GAP.\n\nSome of the features of Semigroupe 2.01 are not yet implemented in\nlibsemigroups; this is a work in progress.  Missing features include\nthose for:\n\n- Green's relations, or classes\n- finding a zero\n- minimal ideal, principal left/right ideals, or indeed any ideals\n- inverses\n- local submonoids\n- the kernel\n- variety tests.\nThese will be included in a future version.\n\nLibsemigroups performs roughly the same as Semigroupe 2.01 when there is\na known upper bound on the size of the semigroup being enumerated, and\nthis is used to initialize the data structures for the semigroup; see\nlibsemigroups::Semigroup::reserve for more details.  Note that in\nSemigroupe 2.01 it is always necessary to provide such an upper bound,\nbut in libsemigroups it is not.\n\nLibsemigroups also has some advantages over Semigroupe 2.01:\n- there is a (hopefully) convenient C++ API, which makes it relatively\n  easy to create and manipulate semigroups and monoids\n- there are some multithreaded methods for semigroups and their\n  congruences\n- you do not have to know/guess the size of a semigroup or monoid before\n  you begin\n- libsemigroups supports more types of elements than Semigroupe 2.01\n- it is relatively straightforward to add support for further types of\n  elements and semigroups\n- it is possible to enumerate a certain number of elements of a\n  semigroup or monoid (say if you are looking for an element with a\n  particular property), to stop, and then to start the enumeration again\n  at a later point\n- you can instantiate as many semigroups and monoids as you can fit in\n  memory\n- it is possible to add more generators after a semigroup or monoid has\n  been constructed, without losing or having to recompute any\n  information that was previously known\n- libsemigroups contains rudimentary implementations of the Todd-Coxeter\n  and Knuth-Bendix algorithms for finitely presented semigroups, which\n  can also be used to compute congruences of a (not necessarily finitely\n  presented) semigroup or monoid.\n", 
            "Build Date": " Sun 08 Oct 2017 11:55:53 PM EDT", 
            "Source RPM": " libsemigroups-0.5.2-1.fc27.src.rpm", 
            "Version": " 0.5.2", 
            "Architecture": " i686", 
            "Signature": " RSA/SHA256, Mon 09 Oct 2017 12:19:00 AM EDT, Key ID f55e7430f5282ee4", 
            "Release": " 1.fc27", 
            "Vendor": " Fedora Project", 
            "Packager": " Fedora Project", 
            "Summary": " C++ library for semigroups and monoids", 
            "Size": " 319183"
        }
    }
}